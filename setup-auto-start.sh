#!/bin/bash
set -euo pipefail

# 设置应用自动启动的脚本
# 支持 Ubuntu 和 Arch 系统
# 会在当前用户下设置 app 程序自动启动

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # 无颜色

# 应用程序路径
APP_PATH=""
# 工作目录
WORKING_DIR=""
# 应用程序名称
APP_NAME=""
# 系统类型
SYSTEM_TYPE=""

# 日志函数
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 检查命令是否存在
check_command() {
    command -v "$1" >/dev/null 2>&1 || {
        log_error "需要 $1 命令，但未找到。请先安装。"
        exit 1
    }
}

# 确定系统类型
determine_system() {
    if [ -f "/etc/os-release" ]; then
        . /etc/os-release
        case "$ID" in
        ubuntu)
            SYSTEM_TYPE="ubuntu"
            ;;
        arch)
            SYSTEM_TYPE="arch"
            ;;
        *)
            log_error "不支持的系统类型: $ID"
            exit 1
            ;;
        esac
    else
        log_error "无法确定系统类型"
        exit 1
    fi
    log_info "检测到系统: $SYSTEM_TYPE"
}

# 获取应用路径
get_app_path() {
    while [ -z "$APP_PATH" ]; do
        read -p "请输入应用程序的绝对路径: " -r APP_PATH
        if ! [[ "$APP_PATH" == /* ]]; then
            log_error "路径必须是绝对路径 (以 / 开头)"
            APP_PATH=""
            continue
        fi
        if [ ! -f "$APP_PATH" ]; then
            log_error "文件不存在: $APP_PATH"
            APP_PATH=""
        elif [ ! -x "$APP_PATH" ]; then
            log_warn "文件不可执行，尝试添加执行权限..."
            chmod +x "$APP_PATH"
            if [ $? -ne 0 ]; then
                log_error "无法添加执行权限，请检查文件权限"
                APP_PATH=""
            else
                log_info "已成功添加执行权限"
            fi
        fi
    done
    
    # 自动从路径中提取应用名称和工作目录
    if [ -z "$APP_NAME" ]; then
        APP_NAME=$(basename "$APP_PATH")
        log_info "自动设置应用名称: $APP_NAME"
    fi
    
    if [ -z "$WORKING_DIR" ]; then
        WORKING_DIR=$(dirname "$APP_PATH")
        log_info "自动设置工作目录: $WORKING_DIR"
    fi
    
    log_info "应用路径: $APP_PATH"
}

# 获取工作目录（可选覆盖）
get_working_dir() {
    read -p "请输入工作目录 (直接回车使用默认: $WORKING_DIR): " -r WORKING_DIR_TEMP
    if [ -n "$WORKING_DIR_TEMP" ]; then
        if [ ! -d "$WORKING_DIR_TEMP" ]; then
            log_error "目录不存在: $WORKING_DIR_TEMP"
            # 返回1会导致set -e退出脚本
            return 1
        else
            WORKING_DIR="$WORKING_DIR_TEMP"
            log_info "工作目录已更新为: $WORKING_DIR"
        fi
    fi
}

# 验证服务名称
validate_app_name() {
    if ! [[ "$APP_NAME" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        log_error "服务名称 '$APP_NAME' 包含非法字符。只允许字母、数字、点、下划线和连字符。"
        exit 1
    fi
}

# 获取应用名称（可选覆盖）
get_app_name_for_install() {
    read -p "请输入服务名称 (直接回车使用默认: $APP_NAME): " -r APP_NAME_TEMP
    if [ -n "$APP_NAME_TEMP" ]; then
        APP_NAME="$APP_NAME_TEMP"
        log_info "服务名称已更新为: $APP_NAME"
    fi
    validate_app_name
}

# 获取应用名称（用于卸载操作）
get_app_name_for_uninstall() {
    while [ -z "$APP_NAME" ]; do
        read -p "请输入要卸载的服务名称: " -r APP_NAME
        if [ -z "$APP_NAME" ]; then
            log_error "服务名称不能为空"
        fi
    done
    validate_app_name
    log_info "服务名称: $APP_NAME"
}

# 创建并配置systemd服务（公共逻辑）
setup_common_service() {
    log_info "开始设置 $APP_NAME 服务..."

    # 创建 systemd 服务目录（如果不存在）
    local SERVICE_DIR="$HOME/.config/systemd/user"
    mkdir -p "$SERVICE_DIR" || {
        log_error "无法创建目录: $SERVICE_DIR"
        exit 1
    }

    # 创建 systemd 服务文件
    local SERVICE_FILE="$SERVICE_DIR/$APP_NAME.service"

    log_info "创建服务文件: $SERVICE_FILE"
    cat >"$SERVICE_FILE" <<EOF
# Generated by setup-auto-start.sh
[Unit]
Description=$APP_NAME Service
After=network.target

[Service]
Type=simple
ExecStart="$APP_PATH"
WorkingDirectory="$WORKING_DIR"
Restart=always
RestartSec=5s

[Install]
WantedBy=default.target
EOF

    # 重新加载 systemd
    log_info "重新加载 systemd 用户实例"
    systemctl --user daemon-reload

    # 启用服务
    log_info "启用 $APP_NAME 服务"
    systemctl --user enable "$APP_NAME.service"

    # 启动服务
    log_info "启动 $APP_NAME 服务"
    systemctl --user start "$APP_NAME.service"

    # 检查服务状态
    log_info "检查 $APP_NAME 服务状态"
    systemctl --user status "$APP_NAME.service"
}

# Ubuntu系统特有的设置
setup_ubuntu_specific() {
    log_info "Ubuntu 系统自动启动设置完成！"
}

# Arch系统特有的设置
setup_arch_specific() {
    # 确保用户登录时启动服务
    log_info "设置用户登录时自动启动服务"
    loginctl enable-linger "$(whoami)"

    log_info "Arch 系统自动启动设置完成！"
}

# 在 Ubuntu 系统上设置自动启动
setup_ubuntu() {
    setup_common_service
    setup_ubuntu_specific
    install_after_info
}

# 在 Arch 系统上设置自动启动
setup_arch() {
    setup_common_service
    setup_arch_specific
    install_after_info
}

install_after_info() {
    log_info "服务控制命令:"
    log_info "  启动: systemctl --user start '$APP_NAME.service'"
    log_info "  停止: systemctl --user stop '$APP_NAME.service'"
    log_info "  重启: systemctl --user restart '$APP_NAME.service'"
    log_info "  状态: systemctl --user status '$APP_NAME.service'"
}

# 卸载服务（公共逻辑）
uninstall_common_service() {
    log_info "开始卸载 $APP_NAME 服务..."

    # 停止服务
    log_info "停止 $APP_NAME 服务"
    systemctl --user stop "$APP_NAME.service" || log_warn "服务未运行或停止失败"

    # 禁用服务
    log_info "禁用 $APP_NAME 服务"
    systemctl --user disable "$APP_NAME.service" || log_warn "服务未启用或禁用失败"

    # 重新加载 systemd
    log_info "重新加载 systemd 用户实例"
    systemctl --user daemon-reload

    # 删除服务文件
    local SERVICE_FILE="$HOME/.config/systemd/user/$APP_NAME.service"
    if [ -f "$SERVICE_FILE" ]; then
        log_info "删除服务文件: $SERVICE_FILE"
        rm -f "$SERVICE_FILE"
    else
        log_warn "服务文件不存在: $SERVICE_FILE"
    fi

    log_info "$APP_NAME 服务卸载完成！"
}

# Ubuntu系统卸载特有的操作
uninstall_ubuntu_specific() {
    log_info "Ubuntu 系统服务卸载完成！"
}

# Arch系统卸载特有的操作
uninstall_arch_specific() {
    # 可选：如果之前启用了linger，可以考虑禁用
    # log_info "禁用用户会话持久化"
    # loginctl disable-linger "$(whoami)"

    log_info "Arch 系统服务卸载完成！"
}

# 在 Ubuntu 系统上卸载服务
uninstall_ubuntu() {
    uninstall_common_service
    uninstall_ubuntu_specific
}

# 在 Arch 系统上卸载服务
uninstall_arch() {
    uninstall_common_service
    uninstall_arch_specific
}

# 列出由本工具管理的服务
list_services() {
    log_info "由本工具管理的服务列表:"
    local SERVICE_DIR="$HOME/.config/systemd/user"
    if [ ! -d "$SERVICE_DIR" ]; then
        log_warn "服务目录不存在: $SERVICE_DIR"
        return
    fi

    # grep -l: 只输出匹配的文件名
    # || true: 防止在没有匹配项时，grep返回非零退出码导致脚本因 set -e 而终止
    local services_found
    services_found=$(grep -l "# Generated by setup-auto-start.sh" "$SERVICE_DIR"/*.service 2>/dev/null || true)

    if [ -z "$services_found" ]; then
        log_info "-> 未找到由本工具管理的服务。"
    else
        # shellcheck disable=SC2001
        echo "$services_found" | sed 's#.*/##; s#\.service$##' | while read -r service; do
            echo "-> $service"
        done
    fi
}


# 显示帮助信息
show_help() {
    echo "用法: $0 [命令]"
    echo "命令:"
    echo "  install     设置应用自动启动"
    echo "  uninstall   卸载应用自动启动服务"
    echo "  list        列出由本工具管理的服务"
    echo "  help        显示此帮助信息"
    exit 0
}

# 解析命令行参数
parse_args() {
    if [ $# -eq 0 ]; then
        show_help
        exit 1
    fi
    
    ACTION="$1"
    
    # 验证操作类型
    case "$ACTION" in
    install|uninstall|list)
        log_info "操作类型: $ACTION"
        ;;
    help)
        show_help
        ;;
    *)
        log_error "未知命令: $ACTION"
        show_help
        ;;
    esac
}

# 主函数
main() {
    # shellcheck disable=SC2124
    parse_args "$@"

    log_info "===== 设置自动启动工具 ($ACTION) ====="

    case "$ACTION" in
    install)
        # 确定系统类型
        determine_system
        # 检查必要的命令
        check_command systemctl
        # 获取应用路径（会自动设置APP_NAME和WORKING_DIR）
        get_app_path
        # 允许用户覆盖自动设置的应用名称
        get_app_name_for_install
        # 允许用户覆盖自动设置的工作目录
        get_working_dir
        # 根据系统类型执行相应的设置
        case "$SYSTEM_TYPE" in
        ubuntu)
            setup_ubuntu
            ;;
        arch)
            setup_arch
            ;;
        esac
        ;;
    uninstall)
        # 确定系统类型
        determine_system
        # 检查必要的命令
        check_command systemctl
        # 卸载操作：获取要卸载的服务名称
        get_app_name_for_uninstall
        # 执行卸载操作
        case "$SYSTEM_TYPE" in
        ubuntu)
            uninstall_ubuntu
            ;;
        arch)
            uninstall_arch
            ;;
        esac
        ;;
    list)
        list_services
        ;;
    esac

    log_info "===== 操作完成 ====="
}

# 执行主函数
main "$@"